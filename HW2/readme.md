1. 개요

1.1. 교과서의 예를 입력으로 하여 정상동작하는 적을 보여라

1.1.1. 행렬 A와 R을 제시하라.

1.1.2. 교과서의 예 이외에 4개의 예를 임의로 만든 후 결과를 제시하라.

1.2. 위의 각각의 결과에 해당하는 최적 이진탐색트리를 함께 제시하라(또는 도시하라)

1.2.1. 즉, 교과서의 예를 포함하여 총 5개 트리 제시 (또는 도시)

--------------------------

2. 상세 설계내용

2.1. 노드 클래스를 따로 만들었습니다.

2.2. A 행렬에 관련된 A 클래스와 r 행렬에 관련된 r 클래스를 만들었습니다.

2.3. 강의 노트에 있는 함수들의 인자들을 동일하게 하려고 클래스를 A와 r로 나누었습니다.

2.4. 노드의 개수와 각각의 확률을 사용자가 입력할 수 있게 만들었습니다.

2.5. 5번 반복하게 하여 한 번만 실행하면 5개의 예를 만들 수 있도록 하였습니다.

2.6. 행렬을 보기 좋게 하기 위해서 A 행렬의 경우에는 정수일 경우에도 소수점이 출력하게 만들었습니다.

2.7. 트리를 출력하는 법은 이진 탐색 트리에 인덱스의 값과 키의 값을 출력하면서 나타내었습니다. (배열로 이진 탐색 트리를 구현했을 때의 인덱스값)

-------------------------

3. 분석 및 결론

3.1. 강의노트에서 OptimalBST함수의 경우에는 A 행렬은 바로 사용하고 r 행렬은 인자로 받아서 사용하고 BuildTee 함수에서는 r 행렬을 바로 사용해서 인자를 똑같이 구현하느라 클래스를 두 개를 만들어서 하게 되었습니다.

3.2. 이진탐색트리를 기반으로 해서 키값이 왼쪽부터 무조건 알파벳 순서대로 되야하므로 확률을 어떻게 주느냐에 따라 트리의 모양이 엄청 달라질 수도 있다는 것을 알 수 있습니다.

3.3. 확률이 높을수록 루트쪽에 가까울 확률이 높지만 주위의 확률에 따라 확률이 더 낮은 것이 루트쪽에 더 가까울 수도 있다는 것을 알 수 있습니다.

3.4. 일반적인 이진탐색트리는 최대한 완전이진트리 모양으로 만드는 것이 유리하지만 이와 다르게 최적 이진 탐색트리의 경우에는 한 쪽에 쏠린 트리가 효율적일 수도 있다는 것을 알 수 있었습니다. (ex. 4~7 개의 경우에는 일반적인 이진 탐색 트리는 3층으로 구성된 트리가 가장 효율적이나 최적 이진 탐색 트리는 확률 때문에 4층 이상이 더 효율적일 수도 있다.)
