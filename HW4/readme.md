1. 개요

1.1. NP-Complete 문제 중 0-1 knapsack문제를 Dynamic Programming 기법과 유전자 알고리즘(Genetic Algorithm)을 이용하여 구현한 후 성능(수행시간)을 비교분석 하라.

1.1.1. 어떤 encoding기법과 selection, crossover, mutation 기법 등이 사용되었는 지 그리고, 어떻게 scaling을 했는 지 자세히 기술할 것

1.1.2. 그 외 어떤 파라미터 값을 이용했는 지 기술할 것

1.1.3. DP와 GA에 대해 5개 이상의 데이터 셋에 대하여 그래프를 그리고 성능을 비교 분석할 것(즉, 최소한 그래프가 5개 이상이어야 함.) 데이터 셋은 아이템의 개수와 W를 변화시켜가면서 5개의 데이터셋을 생성할 것.)

1.2. 0-1 Knapsack 문제를 해결하는 과정을 animation으로 보일 것. (DP, GA 모두)

----------------------------------

2. 상세 설계내용

2.1. DP로 하였을 때, 처음값을 –1로 초기화하여서, -1은 아직 입력이 되지 않은 것으로 하였습니다.

2.2. DP로 하였을 때, 처음값을 계산 수를 줄이기 위해 재귀를 사용하였습니다.

2.3. 단순히 재귀를 사용하면 한 번 사용했던 것을 또 사용하게 되면서 메모리도 많이 소모하고, 시간도 더 걸리기 때문에 재귀를 할 때마다 그 값을 저장을 하여서 똑같은 것을 또 재귀하지 않도록 하였습니다.

2.4. GA를 하기 위해, 유전자를 의미하는 gene 구조체를 만들었습니다.

2.5. 구조체의 배열을 구조체의 원소인 fitness 순서대로 정렬하기 위해 compare 함수를 만들었습니다.

2.6. encoding은 일단 유전자의 길이는 item의 개수로 하고 난 뒤, 이진법으로 encoding 했습니다. 1일 경우에는 그 item이 들어갔다는 의미이고, 0 일 경우에는 그 item이 들어가지 않았다는 의미입니다.

2.7. selection의 경우에는 Ranking selection을 하였습니다. 상위 1/3 은 재생 수가 2개, 하위 1/3은 재생수가 0개 나머지는 1개로 하였습니다.

2.8. crossover의 경우에는 single point crossover를 사용하였습니다. 선택된 상위 1/3 중에서 그것을 절반을 나눠서 서로의 1/4 만큼씩 교환하는 방식을 사용하였습니다.

2.9. mutation의 경우에는 insertion mutation으로 랜덤으로 선택된 값의 부분까지 한 칸씩 앞으로 옮기고 첫 번쨰 원소를 그 선택된 부분으로 옮기는 방식으로 하였습니다.

2.10. mutation의 확률은 약 1% 정도로 하였습니다.

2.11. scaling의 경우에는 Rank Scaling으로 적합도가 높을수록 뒤에 저장을 하였습니다.

2.12. fitness의 경우에는 각 유전자의 원소의 값과 item의 가격을 곱한 값을 fitness로 저장하였습니다. 그런데, 무게가 초과하면 안 되므로, 각 유전자의 원소의 값과 item의 무게를 곱한 값이 최대 무게를 초과할 시 fitness를 10분의 1로 낮추었습니다.

2.13. 자동으로 5번 반복을 하게 만들었고, 사용자가 직접 아이템의 개수와 무게, 가격을 정할 수 있도록 하였습니다.

2.14. selection과 scaling을 위해 fitness 순으로 저장을 해야 하는 데 그러기 위해서 compare 함수를 만들어서 fitness 순으로 유전자들을 배열하도록 하였습니다.

2.15. 결과를 출력할 때는 적합도가 최대인 것의 가격을 출력하도록 하였습니다.

2.16. 애니메이션은 따로 첨부하였고, DP의 경우에는 1-1번 예시로, GA의 경우에는 2-2번 예시로 하였습니다.

2.17. 애니메이션은 #include <windows.h>에서 system(“cls”) 와 Sleep()을 이용하여 만들었습니다.

--------------------------------

3. 분석 및 결론

3.1. DP는 일정한 속도를 보였습니다.

3.2. GA의 경우 세대수와 유전자의 개수를 조작하면서 속도를 조정할 수 있습니다.

3.3. GA의 경우 세대수와 유전자의 개수를 낮추면 속도는 DP보다도 빨라질 수도 있지만 정답이 아닐 확률이 높아집니다. (특히 데이터(item)의 크기가 커질 경우 그 경우가 심합니다.)

3.4. GA의 경우 세대수와 유전자의 개수를 높이면 속도는 DP보다도 훨씬 느려지지만 데이터(item)의 개수가 많아도 정답일 확률이 높아집니다. 

3.5. 따라서 GA의 경우에는 상황에 맞게 item의 개수를 잘 조절하여야될 것 같습니다.
